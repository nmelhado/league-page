import fs__default, { existsSync } from 'fs';
import sade from 'sade';
import { exec as exec$1 } from 'child_process';
import 'net';
import path__default from 'path';
import * as url from 'url';
import { fileURLToPath } from 'url';
import { networkInterfaces, release } from 'os';

let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env);
	isTTY = process.stdout && process.stdout.isTTY;
}

const $ = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

function exec(cmd) {
	return new Promise((fulfil, reject) => {
		exec$1(cmd, (error, stdout, stderr) => {
			if (error) return reject(error);
			fulfil({ stdout, stderr });
		});
	});
}

async function blame(port) {
	try {
		const { stdout } = await exec(`lsof -i :${port} -sTCP:LISTEN -Fp`);

		if (!stdout) return null;
		const pid = parseInt(stdout.slice(1), 10);
		if (isNaN(pid)) throw new Error(`Invalid stdout ${stdout}`);

		return pid;
	} catch (error) {
		return null;
	}
}

/** @param {string} dir */
function mkdirp(dir) {
	try {
		fs__default.mkdirSync(dir, { recursive: true });
	} catch (e) {
		if (e.code === 'EEXIST') return;
		throw e;
	}
}

/** @param {string} path */
function rimraf(path) {
	(fs__default.rmSync || fs__default.rmdirSync)(path, { recursive: true, force: true });
}

/**
 * @param {string} from
 * @param {string} to
 * @param {(basename: string) => boolean} filter
 */
function copy(from, to, filter = () => true) {
	if (!fs__default.existsSync(from)) return [];
	if (!filter(path__default.basename(from))) return [];

	const files = [];
	const stats = fs__default.statSync(from);

	if (stats.isDirectory()) {
		fs__default.readdirSync(from).forEach((file) => {
			files.push(...copy(path__default.join(from, file), path__default.join(to, file)));
		});
	} else {
		mkdirp(path__default.dirname(to));
		fs__default.copyFileSync(from, to);
		files.push(to);
	}

	return files;
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path__default.dirname(__filename);

/** @param {string} dest */
function copy_assets(dest) {
	let prefix = '..';
	do {
		// we jump through these hoops so that this function
		// works whether or not it's been bundled
		const resolved = path__default.resolve(__dirname, `${prefix}/assets`);

		if (fs__default.existsSync(resolved)) {
			copy(resolved, dest);
			return;
		}

		prefix = `../${prefix}`;
	} while (true); // eslint-disable-line
}

function noop() {}

/** @param {{ verbose: boolean }} opts */
function logger({ verbose }) {
	/** @type {import('types/internal').Logger} */
	const log = (msg) => console.log(msg.replace(/^/gm, '  '));

	log.success = (msg) => log($.green(`✔ ${msg}`));
	log.error = (msg) => log($.bold().red(msg));
	log.warn = (msg) => log($.bold().yellow(msg));

	log.minor = verbose ? (msg) => log($.grey(msg)) : noop;
	log.info = verbose ? log : noop;

	return log;
}

/**
 * Given an entry point like [cwd]/src/hooks, returns a filename like [cwd]/src/hooks.js or [cwd]/src/hooks/index.js
 * @param {string} entry
 * @returns {string|null}
 */
function resolve_entry(entry) {
	if (fs__default.existsSync(entry)) {
		const stats = fs__default.statSync(entry);
		if (stats.isDirectory()) {
			return resolve_entry(path__default.join(entry, 'index'));
		}

		return entry;
	} else {
		const dir = path__default.dirname(entry);

		if (fs__default.existsSync(dir)) {
			const base = path__default.basename(entry);
			const files = fs__default.readdirSync(dir);

			const found = files.find((file) => file.replace(/\.[^.]+$/, '') === base);

			if (found) return path__default.join(dir, found);
		}
	}

	return null;
}

/** @param {string} str */
function posixify(str) {
	return str.replace(/\\/g, '/');
}

/**
 * Get a list of packages that use pkg.svelte, so they can be added
 * to ssr.noExternal. This is done on a best-effort basis to reduce
 * the frequency of 'Must use import to load ES Module' and similar
 * @param {string} cwd
 * @returns {string[]}
 */
function find_svelte_packages(cwd) {
	const pkg_file = path__default.join(cwd, 'package.json');
	if (!fs__default.existsSync(pkg_file)) return [];

	const pkg = JSON.parse(fs__default.readFileSync(pkg_file, 'utf8'));

	const deps = [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.devDependencies || {})];

	return deps.filter((dep) => {
		const dep_pkg_file = path__default.join(cwd, 'node_modules', dep, 'package.json');
		if (!fs__default.existsSync(dep_pkg_file)) return false;

		const dep_pkg = JSON.parse(fs__default.readFileSync(dep_pkg_file, 'utf-8'));
		return !!dep_pkg.svelte;
	});
}

/**
 * @param {string} cwd
 * @param {string[]} [user_specified_deps]
 */
function get_no_external(cwd, user_specified_deps = []) {
	return [...user_specified_deps, ...find_svelte_packages(cwd)];
}

const identity = (/** @type {any} */ id) => id;

/** @typedef {import('./types').ConfigDefinition} ConfigDefinition */

/** @type {Record<string, ConfigDefinition>} */
const options = {
	compilerOptions: {
		type: 'leaf',
		default: null,
		validate: identity
	},

	extensions: {
		type: 'leaf',
		default: ['.svelte'],
		validate: (option, keypath) => {
			if (!Array.isArray(option) || !option.every((page) => typeof page === 'string')) {
				throw new Error(`${keypath} must be an array of strings`);
			}

			option.forEach((extension) => {
				if (extension[0] !== '.') {
					throw new Error(`Each member of ${keypath} must start with '.' — saw '${extension}'`);
				}

				if (!/^(\.[a-z0-9]+)+$/i.test(extension)) {
					throw new Error(`File extensions must be alphanumeric — saw '${extension}'`);
				}
			});

			return option;
		}
	},

	kit: {
		type: 'branch',
		children: {
			adapter: {
				type: 'leaf',
				default: null,
				validate: (option, keypath) => {
					if (typeof option !== 'object' || !option.adapt) {
						let message = `${keypath} should be an object with an "adapt" method`;

						if (Array.isArray(option) || typeof option === 'string') {
							// for the early adapter adopters
							message += ', rather than the name of an adapter';
						}

						throw new Error(`${message}. See https://kit.svelte.dev/docs#adapters`);
					}

					return option;
				}
			},

			amp: expect_boolean(false),

			appDir: expect_string('_app', false),

			files: {
				type: 'branch',
				children: {
					assets: expect_string('static'),
					hooks: expect_string('src/hooks'),
					lib: expect_string('src/lib'),
					routes: expect_string('src/routes'),
					serviceWorker: expect_string('src/service-worker'),
					// TODO remove this, eventually
					setup: expect_string('src/setup'),
					template: expect_string('src/app.html')
				}
			},

			floc: expect_boolean(false),

			host: expect_string(null),

			hostHeader: expect_string(null),

			hydrate: expect_page_scriptable(async ({ page }) => {
				const leaf = await page;
				return 'hydrate' in leaf ? !!leaf.hydrate : true;
			}),
			serviceWorker: {
				type: 'branch',
				children: {
					exclude: expect_array_of_strings([])
				}
			},

			package: {
				type: 'branch',
				children: {
					dir: expect_string('package'),
					exports: {
						type: 'branch',
						children: {
							include: expect_array_of_strings(['**']),
							exclude: expect_array_of_strings(['_*', '**/_*'])
						}
					},
					files: {
						type: 'branch',
						children: {
							include: expect_array_of_strings(['**']),
							exclude: expect_array_of_strings([])
						}
					},
					emitTypes: expect_boolean(true)
				}
			},

			paths: {
				type: 'branch',
				children: {
					base: expect_string(''),
					assets: expect_string('')
				}
			},

			prerender: {
				type: 'branch',
				children: {
					crawl: expect_boolean(true),
					enabled: expect_page_scriptable(async ({ page }) => !!(await page).prerender),
					// TODO: remove this for the 1.0 release
					force: {
						type: 'leaf',
						default: undefined,
						validate: (option, keypath) => {
							if (typeof option !== undefined) {
								const newSetting = option ? 'continue' : 'fail';
								const needsSetting = newSetting === 'continue';
								throw new Error(
									`${keypath} has been removed in favor of \`onError\`. In your case, set \`onError\` to "${newSetting}"${
										needsSetting ? '' : ' (or leave it undefined)'
									} to get the same behavior as you would with \`force: ${JSON.stringify(option)}\``
								);
							}
						}
					},
					onError: {
						type: 'leaf',
						default: 'fail',
						validate: (option, keypath) => {
							if (typeof option === 'function') return option;
							if (['continue', 'fail'].includes(option)) return option;
							throw new Error(
								`${keypath} should be either a custom function or one of "continue" or "fail"`
							);
						}
					},
					pages: {
						type: 'leaf',
						default: ['*'],
						validate: (option, keypath) => {
							if (!Array.isArray(option) || !option.every((page) => typeof page === 'string')) {
								throw new Error(`${keypath} must be an array of strings`);
							}

							option.forEach((page) => {
								if (page !== '*' && page[0] !== '/') {
									throw new Error(
										`Each member of ${keypath} must be either '*' or an absolute path beginning with '/' — saw '${page}'`
									);
								}
							});

							return option;
						}
					}
				}
			},

			router: expect_page_scriptable(async ({ page }) => {
				const leaf = await page;
				return 'router' in leaf ? !!leaf.router : true;
			}),

			ssr: expect_page_scriptable(async ({ page }) => {
				const leaf = await page;
				return 'ssr' in leaf ? !!leaf.ssr : true;
			}),

			target: expect_string(null),

			trailingSlash: expect_enum(['never', 'always', 'ignore']),

			vite: {
				type: 'leaf',
				default: () => ({}),
				validate: (option, keypath) => {
					if (typeof option === 'object') {
						const config = option;
						option = () => config;
					}

					if (typeof option !== 'function') {
						throw new Error(
							`${keypath} must be a Vite config object (https://vitejs.dev/config) or a function that returns one`
						);
					}

					return option;
				}
			}
		}
	},

	preprocess: {
		type: 'leaf',
		default: null,
		validate: identity
	}
};

/**
 * @param {string | null} string
 * @param {boolean} allow_empty
 * @returns {ConfigDefinition}
 */
function expect_string(string, allow_empty = true) {
	return {
		type: 'leaf',
		default: string,
		validate: (option, keypath) => {
			assert_is_string(option, keypath);
			if (!allow_empty && option === '') {
				throw new Error(`${keypath} cannot be empty`);
			}
			return option;
		}
	};
}

/**
 * @param {string[]} array
 * @returns {ConfigDefinition}
 */
function expect_array_of_strings(array) {
	return {
		type: 'leaf',
		default: array,
		validate: (option, keypath) => {
			if (!Array.isArray(option) || !option.every((glob) => typeof glob === 'string')) {
				throw new Error(`${keypath} must be an array of strings`);
			}
			return option;
		}
	};
}

/**
 * @param {boolean} boolean
 * @returns {ConfigDefinition}
 */
function expect_boolean(boolean) {
	return {
		type: 'leaf',
		default: boolean,
		validate: (option, keypath) => {
			if (typeof option !== 'boolean') {
				throw new Error(`${keypath} should be true or false, if specified`);
			}
			return option;
		}
	};
}

/**
 * @param {import('types/config').ScriptablePageOpt<boolean>} value
 * @returns {ConfigDefinition}
 */
function expect_page_scriptable(value) {
	return {
		type: 'leaf',
		default: value,
		validate: (option, keypath) => {
			if (typeof option !== 'boolean' && typeof option !== 'function') {
				throw new Error(`${keypath} should be a boolean or function that returns one`);
			}
			return option;
		}
	};
}

/**
 * @param {string[]} options
 * @returns {ConfigDefinition}
 */
function expect_enum(options, def = options[0]) {
	return {
		type: 'leaf',
		default: def,
		validate: (option, keypath) => {
			if (!options.includes(option)) {
				// prettier-ignore
				const msg = options.length > 2
					? `${keypath} should be one of ${options.slice(0, -1).map(option => `"${option}"`).join(', ')} or "${options[options.length - 1]}"`
					: `${keypath} should be either "${options[0]}" or "${options[1]}"`;

				throw new Error(msg);
			}
			return option;
		}
	};
}

/**
 * @param {any} option
 * @param {string} keypath
 */
function assert_is_string(option, keypath) {
	if (typeof option !== 'string') {
		throw new Error(`${keypath} should be a string, if specified`);
	}
}

/** @typedef {import('./types').ConfigDefinition} ConfigDefinition */

/**
 * @param {Record<string, ConfigDefinition>} definition
 * @param {any} option
 * @param {string} keypath
 * @returns {any}
 */
function validate(definition, option, keypath) {
	if (typeof option !== 'object') {
		if (typeof option === 'undefined') {
			throw new Error(
				'Your config is missing default exports. Make sure to include "export default config;"'
			);
		} else {
			throw new Error(
				`Unexpected config type "${typeof option}", make sure your default export is an object.`
			);
		}
	}
	for (const key in option) {
		if (!(key in definition)) {
			let message = `Unexpected option ${keypath}.${key}`;

			if (keypath === 'config' && key in options.kit) {
				message += ` (did you mean config.kit.${key}?)`;
			} else if (keypath === 'config.kit' && key in options) {
				message += ` (did you mean config.${key}?)`;
			}

			throw new Error(message);
		}
	}

	/** @type {Record<string, any>} */
	const merged = {};

	for (const key in definition) {
		const expected = definition[key];
		const actual = option[key];

		const child_keypath = `${keypath}.${key}`;

		if (key in option) {
			if (expected.type === 'branch') {
				if (actual && (typeof actual !== 'object' || Array.isArray(actual))) {
					throw new Error(`${keypath}.${key} should be an object`);
				}

				merged[key] = validate(expected.children, actual, child_keypath);
			} else {
				merged[key] = expected.validate(actual, child_keypath);
			}
		} else {
			merged[key] =
				expected.type === 'branch'
					? validate(expected.children, {}, child_keypath)
					: expected.default;
		}
	}

	return merged;
}

/**
 * @param {string} from
 * @param {string} to
 */
function resolve(from, to) {
	// the `/.` is weird, but allows `${assets}/images/blah.jpg` to work
	// when `assets` is empty
	return remove_trailing_slash(url.resolve(add_trailing_slash(from), to)) || '/.';
}

/**
 * @param {string} str
 */
function add_trailing_slash(str) {
	return str.endsWith('/') ? str : `${str}/`;
}

/**
 * @param {string} str
 */
function remove_trailing_slash(str) {
	return str.endsWith('/') ? str.slice(0, -1) : str;
}

/**
 * @param {string} cwd
 * @param {import('types/config').ValidatedConfig} validated
 */
function validate_template(cwd, validated) {
	const { template } = validated.kit.files;
	const relative = path__default.relative(cwd, template);

	if (fs__default.existsSync(template)) {
		const contents = fs__default.readFileSync(template, 'utf8');
		const expected_tags = ['%svelte.head%', '%svelte.body%'];
		expected_tags.forEach((tag) => {
			if (contents.indexOf(tag) === -1) {
				throw new Error(`${relative} is missing ${tag}`);
			}
		});
	} else {
		throw new Error(`${relative} does not exist`);
	}
}

async function load_config({ cwd = process.cwd() } = {}) {
	const config_file_esm = path__default.join(cwd, 'svelte.config.js');
	const config_file = fs__default.existsSync(config_file_esm)
		? config_file_esm
		: path__default.join(cwd, 'svelte.config.cjs');
	const config = await import(url.pathToFileURL(config_file).href);
	const validated = validate_config(config.default);

	validated.kit.files.assets = path__default.resolve(cwd, validated.kit.files.assets);
	validated.kit.files.hooks = path__default.resolve(cwd, validated.kit.files.hooks);
	validated.kit.files.lib = path__default.resolve(cwd, validated.kit.files.lib);
	validated.kit.files.routes = path__default.resolve(cwd, validated.kit.files.routes);
	validated.kit.files.serviceWorker = path__default.resolve(cwd, validated.kit.files.serviceWorker);
	validated.kit.files.setup = path__default.resolve(cwd, validated.kit.files.setup);
	validated.kit.files.template = path__default.resolve(cwd, validated.kit.files.template);

	validate_template(cwd, validated);

	// TODO check all the `files` exist when the config is loaded?

	return validated;
}

/**
 * @param {import('types/config').Config} config
 * @returns {import('types/config').ValidatedConfig}
 */
function validate_config(config) {
	/** @type {import('types/config').ValidatedConfig} */
	const validated = validate(options, config, 'config');

	// resolve paths
	const { paths, appDir } = validated.kit;

	if (paths.base !== '' && (paths.base.endsWith('/') || !paths.base.startsWith('/'))) {
		throw new Error(
			"kit.paths.base option must be a root-relative path that starts but doesn't end with '/'. See https://kit.svelte.dev/docs#configuration-paths"
		);
	}

	if (appDir.startsWith('/') || appDir.endsWith('/')) {
		throw new Error(
			"kit.appDir cannot start or end with '/'. See https://kit.svelte.dev/docs#configuration"
		);
	}

	paths.assets = resolve(paths.base, paths.assets);

	return validated;
}

/**
 * Merges b into a, recursively, mutating a.
 * @param {Record<string, any>} a
 * @param {Record<string, any>} b
 * @param {string[]} conflicts array to accumulate conflicts in
 * @param {string[]} path array of property names representing the current
 *     location in the tree
 */
function merge_into(a, b, conflicts = [], path = []) {
	/**
	 * Checks for "plain old Javascript object", typically made as an object
	 * literal. Excludes Arrays and built-in types like Buffer.
	 * @param {any} x
	 */
	const is_plain_object = (x) => typeof x === 'object' && x.constructor === Object;

	for (const prop in b) {
		if (is_plain_object(b[prop])) {
			if (!is_plain_object(a[prop])) {
				if (a[prop] !== undefined) {
					conflicts.push([...path, prop].join('.'));
				}
				a[prop] = {};
			}
			merge_into(a[prop], b[prop], conflicts, [...path, prop]);
		} else if (Array.isArray(b[prop])) {
			if (!Array.isArray(a[prop])) {
				if (a[prop] !== undefined) {
					conflicts.push([...path, prop].join('.'));
				}
				a[prop] = [];
			}
			a[prop].push(...b[prop]);
		} else {
			// Since we're inside a for/in loop which loops over enumerable
			// properties only, we want parity here and to check if 'a' has
			// enumerable-only property 'prop'. Using 'hasOwnProperty' to
			// exclude inherited properties is close enough. It is possible
			// that someone uses Object.defineProperty to create a direct,
			// non-enumerable property but let's not worry about that.
			if (Object.prototype.hasOwnProperty.call(a, prop)) {
				conflicts.push([...path, prop].join('.'));
			}
			a[prop] = b[prop];
		}
	}
}

/**
 * Takes zero or more objects and returns a new object that has all the values
 * deeply merged together. None of the original objects will be mutated at any
 * level, and the returned object will have no references to the original
 * objects at any depth. If there's a conflict the last one wins, except for
 * arrays which will be combined.
 * @param {...Object} objects
 * @returns {[Record<string, any>, string[]]} a 2-tuple with the merged object,
 *     and a list of merge conflicts if there were any, in dotted notation
 */
function deep_merge(...objects) {
	const result = {};
	/** @type {string[]} */
	const conflicts = [];
	objects.forEach((o) => merge_into(result, o, conflicts));
	return [result, conflicts];
}

/**
 * @param {string[]} conflicts - array of conflicts in dotted notation
 * @param {string=} pathPrefix - prepended in front of the path
 * @param {string=} scope - used to prefix the whole error message
 */
function print_config_conflicts(conflicts, pathPrefix = '', scope) {
	const prefix = scope ? scope + ': ' : '';
	const log = logger({ verbose: false });
	conflicts.forEach((conflict) => {
		log.error(
			`${prefix}The value for ${pathPrefix}${conflict} specified in svelte.config.js has been ignored. This option is controlled by SvelteKit.`
		);
	});
}

async function get_config() {
	// TODO this is temporary, for the benefit of early adopters
	if (existsSync('svelte.config.cjs')) {
		// prettier-ignore
		console.error($.bold().red(
			'svelte.config.cjs should be renamed to svelte.config.js and converted to an ES module. See https://kit.svelte.dev/docs#configuration for an example'
		));
	}

	if (existsSync('vite.config.js')) {
		// prettier-ignore
		console.error($.bold().red(
			'Please remove vite.config.js and put Vite config in svelte.config.js: https://kit.svelte.dev/docs#configuration-vite'
		));
	}

	try {
		return await load_config();
	} catch (error) {
		let message = error.message;

		if (
			error.code === 'MODULE_NOT_FOUND' &&
			/Cannot find module svelte\.config\./.test(error.message)
		) {
			message = 'Missing svelte.config.js';
		} else if (error.name === 'SyntaxError') {
			message = 'Malformed svelte.config.js';
		}

		console.error($.bold().red(message));
		console.error($.grey(error.stack));
		process.exit(1);
	}
}

/** @param {Error} error */
function handle_error(error) {
	console.log($.bold().red(`> ${error.message}`));
	if (error.stack) {
		console.log($.gray(error.stack));
	}
	process.exit(1);
}

/**
 * @param {number} port
 * @param {boolean} https
 */
async function launch(port, https) {
	const { exec } = await import('child_process');
	let cmd = 'open';
	if (process.platform == 'win32') {
		cmd = 'start';
	} else if (process.platform == 'linux') {
		if (/microsoft/i.test(release())) {
			cmd = 'cmd.exe /c start';
		} else {
			cmd = 'xdg-open';
		}
	}
	exec(`${cmd} ${https ? 'https' : 'http'}://localhost:${port}`);
}

const prog = sade('svelte-kit').version('1.0.0-next.139');

prog
	.command('dev')
	.describe('Start a development server')
	.option('-p, --port', 'Port', 3000)
	.option('-h, --host', 'Host (only use this on trusted networks)', 'localhost')
	.option('-H, --https', 'Use self-signed HTTPS certificate', false)
	.option('-o, --open', 'Open a browser tab', false)
	.action(async ({ port, host, https, open }) => {
		await check_port(port);

		process.env.NODE_ENV = process.env.NODE_ENV || 'development';
		const config = await get_config();

		const { dev } = await import('./chunks/index.js');

		try {
			const watcher = await dev({ port, host, https, config });

			watcher.on('stdout', (data) => {
				process.stdout.write(data);
			});

			watcher.on('stderr', (data) => {
				process.stderr.write(data);
			});

			welcome({ port, host, https, open });
		} catch (error) {
			handle_error(error);
		}
	});

prog
	.command('build')
	.describe('Create a production build of your app')
	.option('--verbose', 'Log more stuff', false)
	.action(async ({ verbose }) => {
		process.env.NODE_ENV = process.env.NODE_ENV || 'production';
		const config = await get_config();

		try {
			const { build } = await import('./chunks/index5.js');
			const build_data = await build(config);

			console.log(
				`\nRun ${$.bold().cyan('npm run preview')} to preview your production build locally.`
			);

			if (config.kit.adapter) {
				const { adapt } = await import('./chunks/index6.js');
				await adapt(config, build_data, { verbose });

				// this is necessary to close any open db connections, etc
				process.exit(0);
			}

			console.log($.bold().yellow('\nNo adapter specified'));

			// prettier-ignore
			console.log(
				`See ${$.bold().cyan('https://kit.svelte.dev/docs#adapters')} to learn how to configure your app to run on the platform of your choosing`
			);
		} catch (error) {
			handle_error(error);
		}
	});

prog
	.command('preview')
	.describe('Serve an already-built app')
	.option('-p, --port', 'Port', 3000)
	.option('-h, --host', 'Host (only use this on trusted networks)', 'localhost')
	.option('-H, --https', 'Use self-signed HTTPS certificate', false)
	.option('-o, --open', 'Open a browser tab', false)
	.action(async ({ port, host, https, open }) => {
		await check_port(port);

		process.env.NODE_ENV = process.env.NODE_ENV || 'production';
		const config = await get_config();

		const { preview } = await import('./chunks/index7.js');

		try {
			await preview({ port, host, config, https });

			welcome({ port, host, https, open });
		} catch (error) {
			handle_error(error);
		}
	});

// TODO remove this after a few versions
prog
	.command('start')
	.describe('Deprecated — use svelte-kit preview instead')
	.option('-p, --port', 'Port', 3000)
	.option('-h, --host', 'Host (only use this on trusted networks)', 'localhost')
	.option('-H, --https', 'Use self-signed HTTPS certificate', false)
	.option('-o, --open', 'Open a browser tab', false)
	.action(async () => {
		console.log(
			$
				.bold()
				.red(
					'"svelte-kit preview" will now preview your production build locally. Note: it is not intended for production use'
				)
		);
	});

prog
	.command('package')
	.describe('Create a package')
	.option('-d, --dir', 'Destination directory', 'package')
	.action(async () => {
		const config = await get_config();

		const { make_package } = await import('./chunks/index8.js');

		try {
			await make_package(config);
		} catch (error) {
			handle_error(error);
		}
	});

prog.parse(process.argv, { unknown: (arg) => `Unknown option: ${arg}` });

/** @param {number} port */
async function check_port(port) {
	const n = await blame(port);

	if (n) {
		console.log($.bold().red(`Port ${port} is occupied`));

		// prettier-ignore
		console.log(
			`Terminate process ${$.bold(n)} or specify a different port with ${$.bold('--port')}\n`
		);

		process.exit(1);
	}
}

/**
 * @param {{
 *   open: boolean;
 *   host: string;
 *   https: boolean;
 *   port: number;
 * }} param0
 */
function welcome({ port, host, https, open }) {
	if (open) launch(port, https);

	console.log($.bold().cyan(`\n  SvelteKit v${'1.0.0-next.139'}\n`));

	const protocol = https ? 'https:' : 'http:';
	const exposed = host !== 'localhost' && host !== '127.0.0.1';

	Object.values(networkInterfaces()).forEach((interfaces) => {
		if (!interfaces) return;
		interfaces.forEach((details) => {
			if (details.family !== 'IPv4') return;

			// prettier-ignore
			if (details.internal) {
				console.log(`  ${$.gray('local:  ')} ${protocol}//${$.bold(`localhost:${port}`)}`);
			} else {
				if (details.mac === '00:00:00:00:00:00') return;

				if (exposed) {
					console.log(`  ${$.gray('network:')} ${protocol}//${$.bold(`${details.address}:${port}`)}`);
				} else {
					console.log(`  ${$.gray('network: not exposed')}`);
				}
			}
		});
	});

	if (!exposed) {
		console.log('\n  Use --host to expose server to other devices on this network');
	}

	console.log('\n');
}

export { $, resolve_entry as a, posixify as b, copy_assets as c, deep_merge as d, copy as e, get_no_external as g, logger as l, mkdirp as m, print_config_conflicts as p, rimraf as r };
